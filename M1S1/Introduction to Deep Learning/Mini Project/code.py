# -*- coding: utf-8 -*-
"""deeplearningproject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1T5ZqyWkpJjGpqtE_mo8rsujnFD9_0Eay
"""

from google.colab import drive
drive.mount('/content/drive')

# Import the ZipFile module to work with ZIP files
from zipfile import ZipFile

# Create a ZipFile object for the source ZIP file in read ('r') mode
with ZipFile("/content/drive/MyDrive/deep learning project/Nouveau dossier.zip", 'r') as zObject:

# Extract all the members (files and directories) from the ZIP file
# and place them in the specified extraction location
	zObject.extractall(
		path="/content/drive/MyDrive/deep learning project")

import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt


train_gen = tf.keras.preprocessing.image.ImageDataGenerator(
    validation_split=0.2,
    rescale=1./255.,
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    fill_mode='nearest'
)
val_gen = tf.keras.preprocessing.image.ImageDataGenerator(validation_split=0.2,rescale=1./255.)


train_flow = train_gen.flow_from_directory(
    directory=r"/content/drive/MyDrive/deep learning project/Nouveau dossier",
    target_size =(256,256),
    color_mode='rgb',
    class_mode='categorical',
    batch_size=8,
    seed=54,
    subset='training')

val_flow = val_gen.flow_from_directory(
    directory=r"/content/drive/MyDrive/deep learning project/Nouveau dossier",
    target_size =(256,256),
    color_mode='rgb',
    class_mode='categorical',
    batch_size=8,
    seed=54,
    subset='validation')

classes_names = train_flow.class_indices

model = tf.keras.applications.MobileNetV2(input_shape=(256,256,3),
                                          include_top=False,
                                          weights='imagenet')
# Freeze all layers except the last few
for layer in model.layers[:-30]:
    layer.trainable = False

# Add custom classification layers to the model.
x = tf.keras.layers.GlobalAveragePooling2D()(model.output)
x = tf.keras.layers.Dropout(0.7)(x)
x = tf.keras.layers.Dense(256, activation='relu')(x)
output = tf.keras.layers.Dense(6, activation='softmax')(x)

# Create a new model with the custom classification layers.
model = tf.keras.Model(inputs=model.input, outputs=output)

# Compile the model with optimizer, loss, and metrics for training.
model.compile(optimizer = tf.keras.optimizers.Adam(learning_rate= 0.000001),
                 loss = 'categorical_crossentropy',
                 metrics = 'accuracy')

# Train the model on the training data and validate on the validation data.
history = model.fit(
    train_flow,
    epochs=75,
    batch_size = 8,
    validation_data=val_flow
)

# Extract training history data for later visualization.
train_loss = history.history['loss']
val_loss = history.history['val_loss']
train_accuracy = history.history['accuracy']
val_accuracy = history.history['val_accuracy']

# Plot training and validation loss and accuracy using Matplotlib.
plt.figure(figsize=(12, 4))
plt.subplot(1, 2, 1)
plt.plot(range(1, len(train_loss) + 1), train_loss, label='Training Loss')
plt.plot(range(1, len(val_loss) + 1), val_loss, label='Validation Loss')
plt.ylabel('Loss')
plt.xlabel('Epochs')
plt.legend()
plt.title('Training and Validation Loss')

plt.subplot(1, 2, 2)
plt.plot(range(1, len(train_accuracy) + 1), train_accuracy, label='Training Accuracy')
plt.plot(range(1, len(val_accuracy) + 1), val_accuracy, label='Validation Accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epochs')
plt.legend()
plt.title('Training and Validation Accuracy')

plt.show()

from sklearn.metrics import confusion_matrix
import seaborn as sns

# Make predictions on the validation data.
val_predictions = model.predict(val_flow)

# Convert predicted probabilities to class labels.
val_predicted_labels = np.argmax(val_predictions, axis=1)

# Get true labels for the validation data.
true_labels = val_flow.classes

# Calculate the confusion matrix for evaluation.
confusion = confusion_matrix(true_labels, val_predicted_labels)

# Plot the confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(confusion, annot=True, fmt='d', cmap='Blues', xticklabels=classes_names, yticklabels=classes_names)
plt.ylabel('True')
plt.xlabel('Predicted')
plt.title('Confusion Matrix')
plt.show()